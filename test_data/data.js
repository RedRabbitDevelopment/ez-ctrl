// Generated by CoffeeScript 1.6.3
var BaseController, ErrorHandler, MyBaseController, Q, UserData, Validator, base, middleware;

Q = require('q');

base = require('../index');

BaseController = base.BaseController;

Validator = base.Validator;

exports.middleware = middleware = {};

UserData = null;

exports.resetData = function() {
  UserData = [
    {
      name: "Nathan Tate",
      username: "yourdeveloperfriend",
      password: "password1"
    }, {
      name: "Shirle Tate",
      username: "hotstuff5",
      password: "password2"
    }, {
      name: "Baby Tate",
      username: "soonToCome",
      password: "password3"
    }
  ];
  middleware.myBaseRan = 0;
  middleware.userRan = 0;
  return middleware.asyncRan = 0;
};

exports.getData = function() {
  return UserData;
};

exports.resetData();

Validator.registerValidator("unique", function(validatorResult, validatorData, controllerName) {
  if (validatorData) {
    return "must be unique";
  } else {
    return "must not be unique";
  }
}, function(value, data, field, controllerName) {
  var isUnique, user, _i, _len;
  isUnique = true;
  for (_i = 0, _len = UserData.length; _i < _len; _i++) {
    user = UserData[_i];
    if (user[field] === value) {
      isUnique = false;
    }
  }
  return isUnique === data;
});

Validator.registerValidator("inDb", function(validatorResult, validatorData) {
  if (validatorData) {
    return "does not exist";
  } else {
    return "must not exist";
  }
}, function(value, data, field, controllerName) {
  var deferred;
  deferred = Q.defer();
  setTimeout(function() {
    var found;
    found = UserData.length > value;
    if (found === data) {
      return deferred.resolve();
    } else {
      return deferred.reject();
    }
  }, 25);
  return deferred.promise;
});

Validator.on("error", console.log);

exports.ErrorHandler = ErrorHandler = {
  expect: function(callback) {
    return this.callback = callback;
  },
  logError: function(error) {
    if (this.callback) {
      this.callback(error);
      return this.callback = false;
    } else {
      console.log("ServerError", error.message);
      return console.log(error.stack);
    }
  }
};

MyBaseController = BaseController.extend({
  beforeEach: function(req, res, next) {
    middleware.myBaseRan++;
    return next();
  }
});

MyBaseController.prototype.logError = function(error) {
  return ErrorHandler.logError(error);
};

exports.UserController = MyBaseController.extend({
  name: "User",
  beforeEach: function(req, res, next) {
    middleware.userRan++;
    return next();
  },
  routes: {
    query: function() {
      return UserData;
    },
    get: {
      validation: {
        id: {
          required: true,
          type: 'int',
          inDb: true
        }
      },
      logic: function(id) {
        return UserData[id];
      }
    },
    add: {
      validation: {
        name: {
          required: true,
          type: "text",
          length: {
            gt: 8
          }
        },
        username: {
          required: true,
          type: 'alphaNumeric',
          unique: true,
          length: {
            gt: 9
          }
        },
        password: {
          required: true,
          type: 'alphaNumeric',
          length: {
            gt: 8
          }
        }
      },
      logic: function(_data) {
        _data.id = UserData.length;
        _data.comments = [];
        UserData.push(_data);
        return true;
      }
    },
    save: {
      validation: {
        id: {
          required: true,
          type: 'int',
          inDb: true
        },
        name: {
          length: {
            gt: 8
          }
        },
        username: {
          type: 'alphaNumeric',
          unique: true,
          length: {
            gt: 8
          }
        },
        password: {
          type: 'alphaNumeric',
          length: {
            gt: 8
          }
        }
      },
      logic: function(id, _data) {
        var key, value;
        for (key in _data) {
          value = _data[key];
          UserData[id][key] = value;
        }
        return true;
      }
    },
    postLogin: {
      validation: {
        username: {
          required: true
        },
        password: {
          required: true
        }
      },
      logic: function(username, password) {
        var user, _i, _len;
        for (_i = 0, _len = UserData.length; _i < _len; _i++) {
          user = UserData[_i];
          if (user.username === username) {
            if (user.password === password) {
              return true;
            } else {
              throw new Error("Invalid username or password");
            }
          }
        }
        throw new Error("Invalid username or password");
      }
    },
    faulty: function() {
      var method;
      method = null;
      method();
      return "Result";
    },
    usesId: {
      validation: {
        id: {
          type: 'int',
          required: true,
          inDb: true
        }
      },
      usesId: true,
      logic: function(id) {
        return "Result";
      }
    }
  }
});

exports.AsyncUserController = MyBaseController.extend({
  name: "AsyncUser",
  beforeEach: function(req, res, next) {
    middleware.asyncRan++;
    return next();
  },
  routes: {
    query: function() {
      var deferred;
      deferred = Q.defer();
      setTimeout(function() {
        return deferred.resolve(UserData);
      }, 25);
      return deferred.promise;
    },
    get: {
      validation: {
        id: {
          required: true,
          type: 'int',
          inDb: true
        }
      },
      logic: function(id) {
        var deferred;
        deferred = Q.defer();
        setTimeout(function() {
          return deferred.resolve(UserData[id]);
        }, 25);
        return deferred.promise;
      }
    },
    add: {
      validation: {
        name: {
          required: true,
          type: "text",
          length: {
            gt: 8
          }
        },
        username: {
          required: true,
          type: 'alphaNumeric',
          length: {
            gt: 8
          }
        },
        password: {
          required: true,
          length: {
            gt: 8
          },
          type: 'alphaNumeric',
          unique: true
        }
      },
      logic: function(_data) {
        var deferred;
        deferred = Q.defer();
        setTimeout(function() {
          _data.id = UserData.length;
          _data.comments = [];
          UserData.push(_data);
          return deferred.resolve(true);
        }, 25);
        return deferred.promise;
      }
    },
    save: {
      validation: {
        id: {
          required: true,
          type: 'int',
          inDb: true
        },
        name: {
          required: true,
          length: {
            gt: 8
          }
        },
        username: {
          type: 'alphaNumeric',
          length: {
            gt: 8
          }
        },
        password: {
          type: 'alphaNumeric',
          length: {
            gt: 8
          }
        }
      },
      logic: function(id, _data) {
        var deferred;
        deferred = Q.defer();
        setTimeout(function() {
          var key, value;
          for (key in _data) {
            value = _data[key];
            UserData[id][key] = value;
          }
          return deferred.resolve(true);
        }, 25);
        return deferred.promise;
      }
    },
    postLogin: {
      validation: {
        username: {
          required: true
        },
        password: {
          required: true
        }
      },
      logic: function(username, password) {
        var deferred;
        deferred = Q.defer();
        setTimeout(function() {
          var user, _i, _len;
          for (_i = 0, _len = UserData.length; _i < _len; _i++) {
            user = UserData[_i];
            user = UserData[id];
            if (user.username === username) {
              if (user.password === password) {
                deferred.resolve(true);
              } else {
                deferred.reject("Invalid username or password");
              }
            }
          }
          return deferred.reject("Invalid username or password");
        }, 25);
        return deferred.promise;
      }
    }
  }
});
