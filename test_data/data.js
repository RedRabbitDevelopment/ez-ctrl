// Generated by CoffeeScript 1.7.1
(function() {
  var ErrorHandler, Q, UserData, UserError, Validator, base, beforeEach, middleware;

  Q = require('q');

  base = require('../index');

  Validator = base.Validator;

  UserError = base.UserError;

  exports.middleware = middleware = {};

  exports.beforeEach = beforeEach = {};

  exports.UserData = UserData = [];

  exports.resetData = function() {
    UserData.splice(0, 5, {
      name: "Nathan Tate",
      username: "yourdeveloperfriend",
      password: "password1"
    }, {
      name: "Shirle Tate",
      username: "hotstuff5",
      password: "password2"
    }, {
      name: "Baby Tate",
      username: "soonToCome",
      password: "password3"
    });
    middleware.myBaseRan = 0;
    middleware.userRan = 0;
    middleware.asyncRan = 0;
    beforeEach.myBaseRan = 0;
    beforeEach.userRan = 0;
    beforeEach.asyncRan = 0;
    return beforeEach.other = {};
  };

  exports.getData = function() {
    return UserData.slice(0);
  };

  exports.resetData();

  Validator.registerValidator("unique", function(value, data, field, controllerName) {
    var isUnique, user, _i, _len;
    isUnique = true;
    for (_i = 0, _len = UserData.length; _i < _len; _i++) {
      user = UserData[_i];
      if (user[field] === value) {
        isUnique = false;
      }
    }
    if (isUnique !== data) {
      throw new UserError(data ? "must be unique" : "does not exist");
    }
  });

  Validator.registerValidator("inDb", function(value, data, field, controllerName) {
    var deferred;
    deferred = Q.defer();
    setTimeout(function() {
      var found;
      found = UserData.length > value;
      if (found === data) {
        return deferred.resolve();
      } else {
        return deferred.reject(data ? "does not exist" : "must not exist");
      }
    }, 25);
    return deferred.promise;
  });

  exports.ErrorHandler = ErrorHandler = {
    expect: function(callback) {
      return this.callback = callback;
    },
    logError: function(error) {
      if (this.callback) {
        this.callback(error);
        return this.callback = false;
      } else {
        console.log("ServerError", error.message);
        return console.log(error.stack);
      }
    }
  };

}).call(this);
