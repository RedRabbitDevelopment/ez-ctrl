// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Q, exportObject, loadValidator, underscore;
  if (!(typeof process === 'undefined' || !process.versions)) {
    EventEmitter = require('events').EventEmitter;
    underscore = require('underscore');
    Q = require('q');
    exportObject = function(object) {
      return module.exports = object;
    };
  } else {
    underscore = _;
    EventEmitter = null;
    if (!Q) {
      throw new Exception("Q is required for ez-validator!");
    }
    exportObject = function(object) {
      return window.Validator = object;
    };
  }
  loadValidator = function(exportObject, Q, _, EventEmitter) {
    var Validator;
    Validator = {
      validate: function(validation, data, controllerName) {
        var field, promises, validatorData;
        promises = [];
        for (field in validation) {
          validatorData = validation[field];
          promises.push(this.validateField(validatorData, field, data[field], controllerName));
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, errors;
          deferred = Q.defer();
          errors = _.filter(results, function(result) {
            return result.state !== "fulfilled";
          });
          if (errors.length > 0) {
            errors = _.reduce(errors, function(memo, result) {
              var reason;
              reason = result.reason;
              _.reduce(reason, function(memo, result) {
                if (!memo[result.field]) {
                  memo[result.field] = [];
                }
                memo[result.field] = memo[result.field].concat(result.errors);
                return memo;
              }, memo);
              return memo;
            }, {});
            deferred.reject({
              message: "validate",
              error: errors
            });
          } else {
            deferred.resolve(data);
          }
          return deferred.promise;
        });
      },
      /*
      			Returns a promise that includes all the readable errors for that field in the format: list of
      				field: name of the field
      				errors: list of readable errors. Example: ['must be less than 8', 'must exist']
      */

      validateField: function(validators, field, value, controllerName) {
        var promises, validator, validatorData;
        promises = [];
        if (!value) {
          if (validators.required) {
            return this.runValidateAndGetReadableError(value, 'required', true, field, controllerName).fail(function(error) {
              var deferred;
              deferred = Q.defer();
              deferred.reject([
                {
                  field: error.field,
                  errors: error.error
                }
              ]);
              return deferred.promise;
            });
          } else {
            return true;
          }
        }
        if (validators) {
          for (validator in validators) {
            validatorData = validators[validator];
            if (validator === "type") {
              validator = validatorData;
              if (!this.ValidationMethods[validator]) {
                continue;
              }
            }
            promises.push(this.runValidateAndGetReadableError(value, validator, validatorData, field, controllerName));
          }
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, error, readableErrors, result, _i, _len;
          deferred = Q.defer();
          readableErrors = [];
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            result = results[_i];
            if (result.state !== "fulfilled") {
              error = result.reason;
              readableErrors.push({
                field: error.field,
                errors: error.error
              });
            }
          }
          if (readableErrors.length > 0) {
            deferred.reject(readableErrors);
          } else {
            deferred.resolve();
          }
          return deferred.promise;
        });
      },
      /*
      			Returns a promise that either is resolved, or is rejected with the following result:
      				field: name of the field that failed
      				error: the readable error
      */

      runValidateAndGetReadableError: function(value, validator, validatorData, field, controllerName) {
        var _this = this;
        return this.runValidate(value, validator, validatorData, field, controllerName).then(function(result) {
          var deferred;
          if (!(result === true || typeof result === "undefined")) {
            deferred = Q.defer();
            deferred.reject(result);
            return deferred.promise;
          }
        }).fail(function(error) {
          var deferred;
          deferred = Q.defer();
          deferred.reject({
            field: field,
            error: _this.translateValidationError(validator, error, validatorData, controllerName)
          });
          return deferred.promise;
        });
      },
      runValidate: function(value, validator, validatorData, field, controllerName) {
        var deferred, e;
        deferred = Q.defer();
        try {
          if (!this.ValidationMethods[validator]) {
            throw new Error("Validation Method " + validator + " does not exist");
          }
          deferred.resolve(this.ValidationMethods[validator](value, validatorData, field, controllerName));
        } catch (_error) {
          e = _error;
          deferred.reject(e.message);
        }
        return deferred.promise;
      },
      translateValidationError: function(validator, validatorResult, validatorData, controllerName) {
        var validationMessage;
        if (this.ValidationMessages[validator]) {
          if (_.isFunction(this.ValidationMessages[validator])) {
            validationMessage = this.ValidationMessages[validator](validatorResult, validatorData, controllerName);
          } else {
            validationMessage = this.ValidationMessages[validator];
          }
        } else {
          if (Validator != null) {
            Validator.trigger("error", {
              error: "MissingMessage",
              validator: validator,
              validatorResult: validatorResult,
              validatorData: validatorData
            });
          }
          validationMessage = this.ValidationMessages["default"];
        }
        if (_.isString(validationMessage)) {
          return [validationMessage];
        } else if (_.isArray(validationMessage)) {
          return validationMessage;
        } else {
          throw new Error("Not sure how to interpret validation message: " + validator + " : " + validatorData + " : " + validationMessage);
        }
      },
      registerValidator: function(name, message, fn) {
        this.ValidationMethods[name] = fn;
        return this.ValidationMessages[name] = message;
      },
      ValidationMessages: {
        required: "is required",
        float: "must be a float",
        int: "must be an integer",
        alphaNumeric: "must be alpha-numeric",
        length: function(validatorResult, validatorData) {
          return _.map(validatorResult, function(data) {
            switch (data.error) {
              case "gt":
                return "must be greater than " + data.detail;
              case "lt":
                return "must be less than " + data.detail;
              case "between":
                return "must be between " + data.detail[0] + " and " + data.detail[1];
              default:
                return "requirement " + data.error + " not recognized";
            }
          });
        },
        "default": "is not understood"
      },
      ValidationMethods: {
        required: function(value, details) {
          return (value != null) === details;
        },
        float: function(value) {
          if (_.isString(value)) {
            value = parseFloat(value);
          }
          return _.isNumber(value) && !_.isNaN(value);
        },
        int: function(value) {
          if (_.isString(value)) {
            value = parseFloat(value);
          }
          return _.isNumber(value) && !_.isNaN(value) && value % 1 === 0;
        },
        alphaNumeric: function(value) {
          return /^[a-z0-9]+$/i.test(value);
        },
        length: function(value, details) {
          var detail, errors, fails, key, length;
          length = value.length;
          errors = [];
          for (key in details) {
            detail = details[key];
            fails = (function() {
              switch (key) {
                case "gt":
                  return length < detail;
                case "lt":
                  return length > detail;
                case "between":
                  return length < detail[0] || length > detail[1];
              }
            })();
            if (fails) {
              errors.push({
                error: key,
                detail: detail
              });
            }
          }
          if (errors.length > 0) {
            return errors;
          }
          return true;
        }
      }
    };
    if (EventEmitter) {
      EventEmitter.call(Validator);
      Validator.__proto__ = EventEmitter.prototype;
    }
    return Validator;
  };
  if (!(typeof window !== "undefined" && window !== null ? window.define : void 0)) {
    return exportObject(loadValidator(exportObject, Q, underscore, EventEmitter));
  } else {
    window.define('ez-export-object', [], function() {
      return exportObject;
    });
    window.define('ez-event-emitter', [], function() {
      return EventEmitter;
    });
    return window.define('Validator', ['exportObject', 'q', 'underscore', 'ez-event-emitter'], loadValidator);
  }
})();
