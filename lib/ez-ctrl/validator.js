// Generated by CoffeeScript 1.6.3
var EventEmitter, Q, ValidationMessages, ValidationMethods, Validator, _;

EventEmitter = require('events').EventEmitter;

_ = require('underscore');

Q = require('q');

module.exports = Validator = {
  validate: function(validation, data, controllerName) {
    var field, promises, validatorData;
    promises = [];
    for (field in validation) {
      validatorData = validation[field];
      promises.push(Validator.validateField(validatorData, field, data[field], controllerName));
    }
    return Q.allSettled(promises).then(function(results) {
      var deferred, errors;
      deferred = Q.defer();
      errors = _.filter(results, function(result) {
        return result.state !== "fulfilled";
      });
      if (errors.length > 0) {
        errors = _.reduce(errors, function(memo, result) {
          var reason;
          reason = result.reason;
          _.reduce(reason, function(memo, result) {
            if (!memo[result.field]) {
              memo[result.field] = [];
            }
            memo[result.field] = memo[result.field].concat(result.errors);
            return memo;
          }, memo);
          return memo;
        }, {});
        deferred.reject({
          message: "validate",
          error: errors
        });
      } else {
        deferred.resolve(data);
      }
      return deferred.promise;
    });
  },
  /*
  	Returns a promise that includes all the readable errors for that field in the format: list of
  		field: name of the field
  		errors: list of readable errors. Example: ['must be less than 8', 'must exist']
  */

  validateField: function(validators, field, value, controllerName) {
    var promises, validator, validatorData;
    promises = [];
    if (!value) {
      if (validators.required) {
        return this.runValidateAndGetReadableError(value, 'required', true, field, controllerName).fail(function(error) {
          var deferred;
          deferred = Q.defer();
          deferred.reject([
            {
              field: error.field,
              errors: error.error
            }
          ]);
          return deferred.promise;
        });
      } else {
        return true;
      }
    }
    if (validators) {
      for (validator in validators) {
        validatorData = validators[validator];
        if (validator === "type") {
          validator = validatorData;
          if (!ValidationMethods[validator]) {
            continue;
          }
        }
        promises.push(this.runValidateAndGetReadableError(value, validator, validatorData, field, controllerName));
      }
    }
    return Q.allSettled(promises).then(function(results) {
      var deferred, error, readableErrors, result, _i, _len;
      deferred = Q.defer();
      readableErrors = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        result = results[_i];
        if (result.state !== "fulfilled") {
          error = result.reason;
          readableErrors.push({
            field: error.field,
            errors: error.error
          });
        }
      }
      if (readableErrors.length > 0) {
        deferred.reject(readableErrors);
      } else {
        deferred.resolve();
      }
      return deferred.promise;
    });
  },
  /*
  	Returns a promise that either is resolved, or is rejected with the following result:
  		field: name of the field that failed
  		error: the readable error
  */

  runValidateAndGetReadableError: function(value, validator, validatorData, field, controllerName) {
    return Validator.runValidate(value, validator, validatorData, field, controllerName).then(function(result) {
      var deferred;
      if (!(result === true || typeof result === "undefined")) {
        deferred = Q.defer();
        deferred.reject(result);
        return deferred.promise;
      }
    }).fail(function(error) {
      var deferred;
      deferred = Q.defer();
      deferred.reject({
        field: field,
        error: Validator.translateValidationError(validator, error, validatorData, controllerName)
      });
      return deferred.promise;
    });
  },
  runValidate: function(value, validator, validatorData, field, controllerName) {
    var deferred, e;
    deferred = Q.defer();
    try {
      if (!ValidationMethods[validator]) {
        throw new Error("Validation Method " + validator + " does not exist");
      }
      deferred.resolve(ValidationMethods[validator](value, validatorData, field, controllerName));
    } catch (_error) {
      e = _error;
      deferred.reject(e.message);
    }
    return deferred.promise;
  },
  translateValidationError: function(validator, validatorResult, validatorData, controllerName) {
    var validationMessage;
    if (ValidationMessages[validator]) {
      if (_.isFunction(ValidationMessages[validator])) {
        validationMessage = ValidationMessages[validator](validatorResult, validatorData, controllerName);
      } else {
        validationMessage = ValidationMessages[validator];
      }
    } else {
      Validator.trigger("error", {
        error: "MissingMessage",
        validator: validator,
        validatorResult: validatorResult,
        validatorData: validatorData
      });
      validationMessage = ValidationMessages["default"];
    }
    if (_.isString(validationMessage)) {
      return [validationMessage];
    } else if (_.isArray(validationMessage)) {
      return validationMessage;
    } else {
      throw new Error("Not sure how to interpret validation message: " + validator + " : " + validatorData + " : " + validationMessage);
    }
  },
  registerValidator: function(name, message, fn) {
    ValidationMethods[name] = fn;
    return ValidationMessages[name] = message;
  }
};

EventEmitter.call(Validator);

Validator.__proto__ = EventEmitter.prototype;

ValidationMessages = {
  required: "is required",
  float: "must be a float",
  int: "must be an integer",
  alphaNumeric: "must be alpha-numeric",
  length: function(validatorResult, validatorData) {
    return _.map(validatorResult, function(data) {
      switch (data.error) {
        case "gt":
          return "must be greater than " + data.detail;
        case "lt":
          return "must be less than " + data.detail;
        case "between":
          return "must be between " + data.detail[0] + " and " + data.detail[1];
        default:
          return "requirement " + data.error + " not recognized";
      }
    });
  },
  "default": "is not understood"
};

ValidationMethods = {
  required: function(value, details) {
    return (value != null) === details;
  },
  float: function(value) {
    if (_.isString(value)) {
      value = parseFloat(value);
    }
    return _.isNumber(value) && !_.isNaN(value);
  },
  int: function(value) {
    if (_.isString(value)) {
      value = parseFloat(value);
    }
    return _.isNumber(value) && !_.isNaN(value) && value % 1 === 0;
  },
  alphaNumeric: function(value) {
    return /^[a-z0-9]+$/i.test(value);
  },
  length: function(value, details) {
    var detail, errors, fails, key, length;
    length = value.length;
    errors = [];
    for (key in details) {
      detail = details[key];
      fails = (function() {
        switch (key) {
          case "gt":
            return length < detail;
          case "lt":
            return length > detail;
          case "between":
            return length < detail[0] || length > detail[1];
        }
      })();
      if (fails) {
        errors.push({
          error: key,
          detail: detail
        });
      }
    }
    if (errors.length > 0) {
      return errors;
    }
    return true;
  }
};
