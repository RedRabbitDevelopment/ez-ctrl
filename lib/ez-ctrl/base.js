// Generated by CoffeeScript 1.6.3
(function() {
  var BaseController, ControllerManager, Converter, FuncDetails, Q, Validator, inflection, _;

  FuncDetails = require('./func-details');

  ControllerManager = require('./manager');

  Converter = require('./converter');

  Q = require('q');

  _ = require('underscore');

  inflection = require('inflection');

  Converter = require('./converter');

  Validator = require('../ez-access/validator');

  module.exports = BaseController = {
    beforeEach: [],
    extend: function(options) {
      var NewController;
      NewController = function(routeDetails) {
        _.extend(this, routeDetails);
        if (_.isFunction(this.initialize)) {
          this.initialize();
        }
        if (options.name) {
          BaseController.setBaseData.call(this, NewController.modelName);
        }
      };
      _.extend(NewController, this);
      if (options.name) {
        NewController.setBaseData(options.name);
      }
      _.extend(NewController, options);
      NewController.beforeEach = this.extendArray('beforeEach', options.beforeEach);
      _.extend(NewController.prototype, this.prototype);
      NewController.prototype.allowedErrors = this.extendArray.call(this.prototype, 'allowedErrors', options.allowedErrors);
      ControllerManager.controllers.push(NewController);
      return NewController;
    },
    extendArray: function(name, extend) {
      var newarray;
      return newarray = extend ? this[name].concat(extend) : this[name].slice(0);
    },
    setBaseData: function(name) {
      this.modelName = name;
      this.tableName = inflection.tableize(this.modelName);
      this.basePattern = "/" + this.tableName;
      this.individualPattern = this.basePattern + "/:id([0-9]+)";
      return this.methods = ["get", "put", "post", "delete"];
    },
    getRouteDetails: function(route) {
      var logic, m, method, middleware, pattern, remainingRoute, routeDetails, usesId, validation, _i, _len, _ref;
      usesId = false;
      routeDetails = this.routes[route];
      switch (route) {
        case "query":
          method = "get";
          pattern = this.basePattern;
          break;
        case "get":
          method = "get";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "add" || "put":
          method = "put";
          pattern = this.basePattern;
          break;
        case "save" || 'post':
          method = "post";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "delete":
          method = "delete";
          pattern = this.individualPattern;
          usesId = true;
          break;
        default:
          remainingRoute = route;
          method = "get";
          _ref = this.methods;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (route.indexOf(m) === 0) {
              method = m;
              remainingRoute = route.substring(method.length);
              break;
            }
          }
          remainingRoute = inflection.underscore(remainingRoute);
          remainingRoute = inflection.dasherize(remainingRoute);
          if (routeDetails.usesId) {
            pattern = this.individualPattern + "/" + remainingRoute;
          } else {
            pattern = this.basePattern + "/" + remainingRoute;
          }
      }
      if (routeDetails.method) {
        method = routeDetails.method;
      }
      if (routeDetails.pattern) {
        pattern = routeDetails.pattern;
      }
      if (routeDetails.usesId) {
        usesId = routeDetails.usesId;
      }
      logic = _.isFunction(routeDetails) ? routeDetails : routeDetails.logic;
      validation = routeDetails.validation || {};
      if (usesId && !validation.id) {
        validation.id = {
          required: true
        };
      }
      middleware = routeDetails.before ? _.isFunction(routeDetails.before) ? [routeDetails.before] : routeDetails.before : [];
      return {
        method: method,
        logic: logic,
        pattern: pattern,
        validation: validation,
        usesId: usesId,
        middleware: middleware
      };
    },
    registerRoute: function(app, routeDetails) {
      var middleware;
      middleware = this.getMiddleWare(routeDetails);
      return app[routeDetails.method](routeDetails.pattern, middleware, this.handleRequest.bind(this, routeDetails));
    },
    getMiddleWare: function(routeDetails) {
      return this.beforeEach.concat(routeDetails.middleware);
    },
    handleRequest: function(routeDetails, req, res, next) {
      var ThisController, controller;
      ThisController = this;
      controller = new ThisController(routeDetails);
      return controller.handleRequest(req, res);
    },
    getRoutes: function() {
      var r, route, routes, _ref;
      routes = {};
      _ref = this.routes;
      for (route in _ref) {
        r = _ref[route];
        routes[route] = this.getRouteDetails(route);
      }
      return routes;
    },
    registerRoutes: function(app) {
      var route, routeDetails, routes, _results;
      routes = this.getRoutes();
      _results = [];
      for (route in routes) {
        routeDetails = routes[route];
        _results.push(this.registerRoute(app, routeDetails));
      }
      return _results;
    }
  };

  BaseController.prototype = {
    allowedErrors: ['validate'],
    handleRequest: function(req, res) {
      var _this = this;
      this.request = req;
      this.response = res;
      return Q.when().then(function() {
        return _this.getData();
      }).then(function(data) {
        return _this.convert(data);
      }).then(function(data) {
        return _this.validate(data);
      }).then(function(data) {
        var logicArguments;
        logicArguments = FuncDetails.dataToArgs(_this.logic, data);
        return _this.logic.apply(_this, logicArguments);
      }).then(function(response) {
        return _this.sendResponse(response);
      }, function(reason) {
        return _this.sendErrorResponse(reason);
      });
    },
    getRequestData: function(field) {
      return this.request.param(field);
    },
    getData: function() {
      var data, field, value, _ref;
      data = {};
      _ref = this.validation;
      for (field in _ref) {
        value = _ref[field];
        value = this.getRequestData(field);
        if (value) {
          data[field] = value;
        }
      }
      return data;
    },
    sendResponse: function(response) {
      return this.response.json({
        success: true,
        response: response
      });
    },
    sendErrorResponse: function(error) {
      var errorType, message;
      errorType = error && error.message ? error.message : error;
      if (-1 !== this.allowedErrors.indexOf(errorType)) {
        message = error.error ? error.error : errorType;
      } else {
        if (_.isFunction(this.logError)) {
          this.logError(error);
        }
        message = "Server Error";
      }
      return this.response.json({
        success: false,
        error: message
      });
    },
    convert: function(data) {
      return Converter.convert(this.validation, data);
    },
    validate: function(data) {
      return Validator.validate(this.validation, data, this.modelName);
    }
  };

}).call(this);
