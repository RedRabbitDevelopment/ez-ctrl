// Generated by CoffeeScript 1.6.3
(function() {
  var BaseController, Converter, FuncDetails, Q, UserError, Validator, inflection, multiparty, util, _;

  FuncDetails = require('./func-details');

  Converter = require('./converter');

  Q = require('q');

  _ = require('underscore');

  inflection = require('inflection');

  Converter = require('./converter');

  Validator = require('../ez-access/validator');

  UserError = require('./userError');

  multiparty = require('multiparty');

  util = require('util');

  module.exports = BaseController = {
    isController: true,
    isAbstract: true,
    beforeEach: [],
    extend: function(options) {
      var NewController;
      NewController = function(routeDetails) {
        _.extend(this, routeDetails);
        if (_.isFunction(this.initialize)) {
          this.initialize();
        }
        if (options.name) {
          BaseController.setBaseData.call(this, NewController.modelName);
        }
      };
      _.extend(NewController, this);
      NewController.isAbstract = false;
      if (options.name) {
        NewController.setBaseData(options.name);
      }
      _.extend(NewController, options);
      NewController.beforeEach = this.extendArray('beforeEach', options.beforeEach);
      _.extend(NewController.prototype, this.prototype);
      return NewController;
    },
    extendArray: function(name, extend) {
      var newarray;
      return newarray = extend ? this[name].concat(extend) : this[name].slice(0);
    },
    setBaseData: function(name) {
      this.modelName = name;
      this.tableName = inflection.tableize(this.modelName);
      this.basePattern = "/" + this.tableName;
      this.individualPattern = this.basePattern + "/:id([0-9]+)";
      return this.methods = ["get", "put", "post", "delete"];
    },
    getRouteDetails: function(route) {
      var logic, m, method, middleware, pattern, remainingRoute, routeDetails, usesId, validation, _i, _len, _ref;
      usesId = false;
      routeDetails = this.routes[route];
      switch (route) {
        case "query":
          method = "get";
          pattern = this.basePattern;
          break;
        case "get":
          method = "get";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "add" || "put":
          method = "put";
          pattern = this.basePattern;
          break;
        case "save" || 'post':
          method = "post";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "delete":
          method = "delete";
          pattern = this.individualPattern;
          usesId = true;
          break;
        default:
          remainingRoute = route;
          method = "get";
          _ref = this.methods;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (route.indexOf(m) === 0) {
              method = m;
              remainingRoute = route.substring(method.length);
              break;
            }
          }
          remainingRoute = inflection.underscore(remainingRoute);
          remainingRoute = inflection.dasherize(remainingRoute);
          if (routeDetails.usesId) {
            pattern = this.individualPattern + "/" + remainingRoute;
          } else {
            pattern = this.basePattern + "/" + remainingRoute;
          }
      }
      if (routeDetails.method) {
        method = routeDetails.method;
      }
      if (routeDetails.pattern) {
        pattern = routeDetails.pattern;
      }
      if (routeDetails.usesId) {
        usesId = routeDetails.usesId;
      }
      logic = _.isFunction(routeDetails) ? routeDetails : routeDetails.logic;
      validation = routeDetails.validation || {};
      if (usesId && !validation.id) {
        validation.id = {
          required: true
        };
      }
      middleware = routeDetails.before ? _.isFunction(routeDetails.before) ? [routeDetails.before] : routeDetails.before : [];
      return {
        method: method,
        logic: logic,
        pattern: pattern,
        validation: validation,
        usesId: usesId,
        middleware: middleware
      };
    },
    registerRoute: function(app, routeDetails) {
      var middleware;
      middleware = this.getMiddleWare(routeDetails);
      return app[routeDetails.method](routeDetails.pattern, middleware, this.handleRequest.bind(this, routeDetails));
    },
    getMiddleWare: function(routeDetails) {
      return this.beforeEach.concat(routeDetails.middleware);
    },
    handleRequest: function(routeDetails, req, res, next) {
      var controller;
      controller = new this(routeDetails);
      return controller.handleRequest(req, res);
    },
    getRoutes: function() {
      var r, route, routes, _ref;
      routes = {};
      _ref = this.routes;
      for (route in _ref) {
        r = _ref[route];
        routes[route] = this.getRouteDetails(route);
      }
      return routes;
    },
    registerRoutes: function(app) {
      var route, routeDetails, routes, _results;
      routes = this.getRoutes();
      _results = [];
      for (route in routes) {
        routeDetails = routes[route];
        _results.push(this.registerRoute(app, routeDetails));
      }
      return _results;
    },
    getController: function(route) {
      var controller, routeDetails;
      routeDetails = this.getRouteDetails(route);
      return controller = new this(routeDetails);
    }
  };

  BaseController.prototype = {
    handleRequest: function(req, res) {
      var _this = this;
      this.request = req;
      this.response = res;
      return Q.fcall(function() {
        return _this.getData();
      }).then(function(data) {
        return _this.getResponse(data);
      }).then(function(response) {
        return _this.sendResponse(response);
      }).fail(function(reason) {
        return _this.sendErrorResponse(reason);
      }).fail(function(reason) {
        return console.log("EZController Error unhandled", reason, reason != null ? reason.stack : void 0);
      });
    },
    getResponse: function(data) {
      var _this = this;
      return Q.fcall(function() {
        return _this.convert(data);
      }).then(function(data) {
        return _this.validate(data);
      }).then(function(data) {
        return _this.runLogic(data);
      });
    },
    runLogic: function(data) {
      var _this = this;
      return Q.fcall(function() {
        var logicArguments;
        logicArguments = FuncDetails.dataToArgs(_this.logic, data);
        return _this.logic.apply(_this, logicArguments);
      });
    },
    getRequestData: function(field, type) {
      var _ref,
        _this = this;
      if (type === 'file') {
        if (this.files) {
          return (_ref = this.files[field]) != null ? _ref[0] : void 0;
        } else {
          return this.parseFiles().then(function() {
            var _ref1, _ref2;
            return (_ref1 = _this.files) != null ? (_ref2 = _ref1[field]) != null ? _ref2[0] : void 0 : void 0;
          });
        }
      } else {
        return Q.fcall(function() {
          return _this.request.param(field);
        });
      }
    },
    parseFiles: function() {
      var form,
        _this = this;
      form = new multiparty.Form();
      return Q.ninvoke(form, 'parse', this.request).spread(function(fields, files) {
        return _this.files = files;
      }).fail(function(error) {
        if (error.message === 'Expected CR Received 45') {
          return _this.files = {};
        } else {
          throw error;
        }
      });
    },
    getData: function() {
      var data, field, promises, value;
      data = {};
      promises = (function() {
        var _ref, _results,
          _this = this;
        _ref = this.validation;
        _results = [];
        for (field in _ref) {
          value = _ref[field];
          _results.push((function(field, value) {
            return _this.getRequestData(field, value.type).then(function(value) {
              if (value) {
                return data[field] = value;
              }
            });
          })(field, value));
        }
        return _results;
      }).call(this);
      return Q.all(promises).then(function() {
        return data;
      });
    },
    sendResponse: function(response) {
      return this.response.json({
        success: true,
        response: response
      });
    },
    sendErrorResponse: function(error) {
      var errors, message;
      message = !(error instanceof UserError) ? (_.isFunction(this.logError) ? this.logError(error) : void 0, "Server Error") : (errors = error.errors, error.message);
      return this.response.json({
        success: false,
        error: message,
        errors: errors
      });
    },
    convert: function(data) {
      return Converter.convert(this.validation, data);
    },
    validate: function(data) {
      return Validator.validate(this.validation, data, this.modelName);
    }
  };

}).call(this);
