// Generated by CoffeeScript 1.7.1
(function() {
  var BaseController, Converter, FuncDetails, Q, UserError, Validator, inflection, multiparty, util, _;

  FuncDetails = require('./func-details');

  Converter = require('./converter');

  Q = require('q');

  _ = require('lodash');

  inflection = require('inflection');

  Converter = require('./converter');

  Validator = require('../ez-access/validator');

  UserError = require('./userError');

  multiparty = require('multiparty');

  util = require('util');

  module.exports = BaseController = {
    isController: true,
    isAbstract: true,
    beforeEach: [],
    middleware: [],
    extend: function(options) {
      var NewController;
      NewController = function(routeDetails) {
        _.extend(this, routeDetails);
        if (_.isFunction(this.initialize)) {
          this.initialize();
        }
        if (options.name) {
          BaseController.setBaseData.call(this, NewController.modelName);
        }
      };
      _.extend(NewController, this);
      NewController.isAbstract = false;
      _.extend(NewController, options);
      if (options.name) {
        NewController.setBaseData(options.name, NewController.idRegex);
      }
      NewController.beforeEach = this.extendArray('beforeEach', options.beforeEach);
      NewController.middleware = this.extendArray('middleware', options.middleware);
      _.extend(NewController.prototype, this.prototype, options.methods);
      return NewController;
    },
    extendArray: function(name, extend) {
      var newarray;
      return newarray = extend ? this[name].concat(extend) : this[name].slice(0);
    },
    setBaseData: function(name, idRegex) {
      var idPattern;
      this.modelName = name;
      this.tableName = inflection.tableize(this.modelName);
      this.basePattern = "/" + this.tableName;
      idPattern = idRegex != null ? idRegex === false ? '' : "(" + idRegex + ")" : '([0-9]+)';
      this.individualPattern = "" + this.basePattern + "/:id" + idPattern;
      return this.methods = ["get", "put", "post", "delete"];
    },
    getRouteDetails: function(route) {
      var before, logic, m, method, middleware, pattern, remainingRoute, routeDetails, usesId, validation, _i, _len, _ref;
      usesId = false;
      routeDetails = this.routes[route];
      switch (route) {
        case "query":
          method = "get";
          pattern = this.basePattern;
          break;
        case "get":
          method = "get";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "add" || "post":
          method = "post";
          pattern = this.basePattern;
          break;
        case "save" || 'put':
          method = "put";
          pattern = this.individualPattern;
          usesId = true;
          break;
        case "delete":
          method = "delete";
          pattern = this.individualPattern;
          usesId = true;
          break;
        default:
          remainingRoute = route;
          method = "get";
          _ref = this.methods;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            if (route.indexOf(m) === 0) {
              method = m;
              remainingRoute = route.substring(method.length);
              break;
            }
          }
          remainingRoute = inflection.underscore(remainingRoute);
          remainingRoute = inflection.dasherize(remainingRoute);
          if (routeDetails.usesId) {
            pattern = this.individualPattern + "/" + remainingRoute;
          } else {
            pattern = this.basePattern + "/" + remainingRoute;
          }
      }
      if (routeDetails.method) {
        method = routeDetails.method;
      }
      before = [];
      if (this.beforeEach) {
        before = before.concat(this.beforeEach);
      }
      if (routeDetails.before) {
        before = before.concat(routeDetails.before);
      }
      if (routeDetails.pattern) {
        pattern = routeDetails.pattern;
      }
      if (routeDetails.usesId) {
        usesId = routeDetails.usesId;
      }
      logic = _.isFunction(routeDetails) ? routeDetails : routeDetails.logic;
      validation = routeDetails.validation || {};
      if (usesId && !validation.id) {
        validation.id = {
          required: true
        };
      }
      middleware = routeDetails.middleware ? _.isFunction(routeDetails.middleware) ? [routeDetails.middleware] : routeDetails.middleware : [];
      return {
        method: method,
        route: route,
        logic: logic,
        before: before,
        pattern: pattern,
        validation: validation,
        usesId: usesId,
        middleware: middleware
      };
    },
    registerRoute: function(app, routeDetails) {
      var middleware;
      middleware = this.getMiddleWare(routeDetails);
      return app[routeDetails.method](routeDetails.pattern, middleware, this.handleRequest.bind(this, routeDetails));
    },
    getMiddleWare: function(routeDetails) {
      return this.middleware.concat(routeDetails.middleware);
    },
    handleRequest: function(routeDetails, req, res, next) {
      var controller;
      controller = new this(routeDetails);
      return controller.handleRequest(req, res, next);
    },
    getRoutes: function() {
      var r, route, routes, _ref;
      routes = {};
      _ref = this.routes;
      for (route in _ref) {
        r = _ref[route];
        routes[route] = this.getRouteDetails(route);
      }
      return routes;
    },
    registerRoutes: function(app) {
      var route, routeDetails, routes, _results;
      routes = this.getRoutes();
      _results = [];
      for (route in routes) {
        routeDetails = routes[route];
        _results.push(this.registerRoute(app, routeDetails));
      }
      return _results;
    },
    getController: function(route) {
      var controller, routeDetails;
      routeDetails = this.getRouteDetails(route);
      return controller = new this(routeDetails);
    }
  };

  BaseController.prototype = {
    handleRequest: function(req, res, next) {
      this.request = req;
      this.response = res;
      this.next = next;
      return this.steps([this.getData, this.runBefore, this.convert, this.validate, this.runLogic, this.translateSuccessResponse]).fail((function(_this) {
        return function(reason) {
          return _this.translateErrorResponse(reason);
        };
      })(this)).then((function(_this) {
        return function(result) {
          return _this.send(result);
        };
      })(this)).fail((function(_this) {
        return function(reason) {
          return console.log("EZController Error unhandled", reason, reason != null ? reason.stack : void 0);
        };
      })(this));
    },
    steps: function(steps, first) {
      var promise;
      promise = Q.when(first);
      return steps.reduce((function(_this) {
        return function(promise, step) {
          return promise.then(step.bind(_this));
        };
      })(this), promise);
    },
    run: function(req, res, data) {
      this.request = req;
      this.response = res;
      return this.steps([this.runBefore, this.convert, this.validate, this.runLogic, this.translateSuccessResponse], data).fail((function(_this) {
        return function(reason) {
          return _this.translateErrorResponse(reason);
        };
      })(this));
    },
    runBefore: function(data, i) {
      if (i == null) {
        i = 0;
      }
      if (i < this.before.length) {
        return Q.fcall((function(_this) {
          return function() {
            return _this.applyFunction(_this.before[i], data);
          };
        })(this)).then((function(_this) {
          return function() {
            return _this.runBefore(data, i + 1);
          };
        })(this));
      } else {
        return data;
      }
    },
    runLogic: function(data) {
      return Q.fcall((function(_this) {
        return function() {
          return _this.applyFunction(_this.logic, data);
        };
      })(this));
    },
    clean: function(object) {
      if (!object) {
        return null;
      } else {
        return JSON.parse(JSON.stringify(object));
      }
    },
    testLogic: function(data) {
      return this.runLogic(this.clean(data)).then(this.clean);
    },
    applyFunction: function(fn, data) {
      var args;
      args = FuncDetails.dataToArgs(fn, data);
      return fn.apply(this, args);
    },
    getRequestData: function(field, type) {
      var _ref;
      if (type === 'file' || type === 'image') {
        if (this.files) {
          return (_ref = this.files[field]) != null ? _ref[0] : void 0;
        } else {
          return this.parseFiles().then((function(_this) {
            return function() {
              var _ref1, _ref2;
              return (_ref1 = _this.files) != null ? (_ref2 = _ref1[field]) != null ? _ref2[0] : void 0 : void 0;
            };
          })(this));
        }
      } else {
        return Q.fcall((function(_this) {
          return function() {
            return _this.request.param(field);
          };
        })(this));
      }
    },
    parseFiles: function() {
      var form;
      form = new multiparty.Form();
      return Q.ninvoke(form, 'parse', this.request).spread((function(_this) {
        return function(fields, files) {
          return _this.files = files;
        };
      })(this)).fail((function(_this) {
        return function(error) {
          if (error.message === 'Expected CR Received 45') {
            return _this.files = {};
          } else {
            throw error;
          }
        };
      })(this));
    },
    getData: function() {
      var data, field, promises, value;
      data = {};
      promises = (function() {
        var _ref, _results;
        _ref = this.validation;
        _results = [];
        for (field in _ref) {
          value = _ref[field];
          _results.push(((function(_this) {
            return function(field, value) {
              return _this.getRequestData(field, value.type).then(function(value) {
                if (value != null) {
                  return data[field] = value;
                }
              });
            };
          })(this))(field, value));
        }
        return _results;
      }).call(this);
      return Q.all(promises).then(function() {
        return data;
      });
    },
    translateSuccessResponse: function(response) {
      return {
        success: true,
        response: response
      };
    },
    translateErrorResponse: function(error) {
      var errors, message;
      message = !(error instanceof UserError) ? (_.isFunction(this.logError) ? this.logError(error) : void 0, "Server Error") : (errors = error.errors, error.message);
      return {
        success: false,
        error: message,
        errors: errors
      };
    },
    send: function(result) {
      if (!this.sent) {
        this.sent = true;
        return this.response.json(result);
      }
    },
    convert: function(data) {
      return Converter.convert(this.validation, data);
    },
    validate: function(data) {
      return Validator.validate(this.validation, data, this.modelName);
    },
    throwValidationError: function(errors) {
      return this.throwError('Validation', errors);
    },
    throwError: function(message, errors) {
      var error;
      error = new UserError(message);
      error.errors = errors;
      throw error;
    }
  };

}).call(this);
