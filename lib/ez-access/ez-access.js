// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(generator) {
    var Q, _;
    if ((typeof exports !== "undefined" && exports !== null) && module.exports) {
      Q = require('q');
      _ = require('lodash');
      return module.exports = generator(Q, _);
    } else if ((typeof define !== "undefined" && define !== null) && define.amd) {
      return define(['q', 'lodash'], generator);
    } else {
      return window.EZAccess = generator(window.Q, window._);
    }
  })(function(Q, _) {
    var BaseController, Batch, BatchController, Controller, EZAccess;
    BaseController = (function() {
      function BaseController(_details) {
        this._details = _details;
        _.assign(this, this._details);
      }

      BaseController.prototype._constructPath = function(pattern, data) {
        var param, params, path, url, value, variable, variables;
        params = pattern.split('/');
        path = ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            param = params[_i];
            if (variables = param.match(/^:(.*?)(\(.*?\))?$/)) {
              variable = variables[1];
              value = data[variable];
              delete data[variable];
              _results.push(value);
            } else {
              _results.push(param);
            }
          }
          return _results;
        })()).join("/");
        if (this.hostname) {
          url = "//" + this.hostname + path;
          if (this.protocol) {
            return "" + this.protocol + ":" + url;
          } else {
            return url;
          }
        } else {
          return path;
        }
      };

      BaseController.prototype._serialize = function(obj, prefix) {
        var i, key, str, value, _i, _len;
        str = [];
        if (obj.length != null) {
          for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
            value = obj[i];
            key = prefix ? "" + prefix + "[" + i + "]" : i;
            if (value !== void 0) {
              str.push(typeof value === 'object' ? this._serialize(value, key) : key + "=" + encodeURIComponent(value));
            }
          }
        } else {
          for (key in obj) {
            value = obj[key];
            key = prefix ? prefix + "[" + key + "]" : encodeURIComponent(key);
            if (value !== void 0) {
              str.push(typeof value === 'object' ? this._serialize(value, key) : key + "=" + encodeURIComponent(value));
            }
          }
        }
        return str.join("&");
      };

      BaseController.prototype._constructQuery = function(data) {
        var result;
        result = this._serialize(data);
        if (result.length > 0) {
          return "?" + result;
        } else {
          return "";
        }
      };

      BaseController.prototype._isFunction = function(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
      };

      BaseController.prototype._makeRequestBase = function(method, path, data) {
        var deferred, xmlhttp;
        deferred = Q.defer();
        xmlhttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
        xmlhttp.onreadystatechange = (function(_this) {
          return function() {
            var e;
            if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
              try {
                return deferred.resolve(JSON.parse(xmlhttp.responseText));
              } catch (_error) {
                e = _error;
                console.log("EZAccessError: Response not in valid JSON", xml.responseText);
                return deferred.reject(error, "EZAccessError: Response not in valid JSON", xml.responseText);
              }
            }
          };
        })(this);
        if (method === 'get') {
          xmlhttp.open(method, path, true);
          xmlhttp.send();
        } else {
          xmlhttp.open(method, path, true);
          xmlhttp.setRequestHeader('Content-Type', 'application/json');
          xmlhttp.send(JSON.stringify(data));
        }
        return deferred.promise;
      };

      BaseController.prototype.interpretResult = function(result) {
        var error;
        if (result.success) {
          return result.response;
        } else {
          error = new Error(result.error);
          error.errors = result.errors;
          throw error;
        }
      };

      return BaseController;

    })();
    Controller = (function(_super) {
      __extends(Controller, _super);

      function Controller() {
        return Controller.__super__.constructor.apply(this, arguments);
      }

      Controller.prototype._makeRequest = function(routeDetails, args, controllerName, methodName) {
        var data;
        data = EZAccess._extractData(routeDetails.argList, args);
        return ((function(_this) {
          return function(data) {
            var path;
            path = _this._constructPath(routeDetails.pattern, data);
            if (routeDetails.method === 'get') {
              path = path + _this._constructQuery(data);
            }
            return _this._makeRequestBase(routeDetails.method, path, data).then(_this.interpretResult);
          };
        })(this))(data);
      };

      return Controller;

    })(BaseController);
    BatchController = (function(_super) {
      __extends(BatchController, _super);

      function BatchController(_details) {
        this._details = _details;
        BatchController.__super__.constructor.apply(this, arguments);
      }

      BatchController.prototype._makeRequest = function(routeDetails, args, controllerName, methodName) {
        return {
          args: EZAccess._extractData(routeDetails.argList, args),
          controllerName: controllerName,
          methodName: methodName
        };
      };

      return BatchController;

    })(BaseController);
    Batch = (function(_super) {
      __extends(Batch, _super);

      function Batch() {
        this.requests = {};
        this.num = 0;
        EZAccess.controllers.map((function(_this) {
          return function(controllerName) {
            return _this[controllerName] = Batch[controllerName];
          };
        })(this));
      }

      Batch.prototype.getRequestId = function() {
        return this.num++;
      };

      Batch.prototype.get = function(varName, request) {
        var key, value, _results;
        if (_.isString(varName)) {
          return this.requests[varName] = request;
        } else {
          _results = [];
          for (key in varName) {
            value = varName[key];
            _results.push(this.get(key, value));
          }
          return _results;
        }
      };

      Batch.prototype.flush = function(ignoreFailures) {
        return this._makeRequestBase('get', "/get-batch" + (this._constructQuery(this.requests))).then((function(_this) {
          return function(results) {
            if (ignoreFailures) {
              return results;
            } else {
              return _.mapValues(results, _this.interpretResult);
            }
          };
        })(this));
      };

      return Batch;

    })(BaseController);
    return EZAccess = {
      BaseController: BaseController,
      Controller: Controller,
      BatchController: BatchController,
      Batch: Batch,
      controllers: [],
      eventualObject: function(promise) {
        var shell;
        shell = {};
        shell._promise = promise.then(function(result) {
          var key, value;
          for (key in result) {
            value = result[key];
            shell[key] = value;
          }
          return shell;
        });
        return shell;
      },
      eventualArray: function(promise) {
        var shell;
        shell = [];
        shell._promise = promise.then(function(result) {
          var i, value, _i, _len;
          for (i = _i = 0, _len = result.length; _i < _len; i = ++_i) {
            value = result[i];
            shell.push(result[i]);
          }
          return shell;
        });
        return shell;
      },
      eventualValue: function(promise) {
        var shell;
        shell = {
          value: null
        };
        promise.then(function(result) {
          return shell.value = result;
        });
        return shell;
      }
    };
  });

}).call(this);
