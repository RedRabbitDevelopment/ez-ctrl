// Generated by CoffeeScript 1.10.0
(function() {
  (function(generator) {
    var Bluebird, UserError, _, validate, validator;
    if ((typeof exports !== "undefined" && exports !== null) && module.exports) {
      _ = require('lodash');
      validate = require('validator');
      Bluebird = require('bluebird');
      UserError = require('../ez-ctrl/userError');
      return module.exports = generator(_, validate, Bluebird, UserError);
    } else if ((typeof define !== "undefined" && define !== null) && define.amd) {
      return define(['lodash', 'validate', 'bluebird', 'UserError'], generator);
    } else {
      _ = window._, validator = window.validator, Bluebird = window.Bluebird, UserError = window.UserError;
      return window.Validator = generator(_, validator, Bluebird, UserError);
    }
  })(function(_, validate, Bluebird, UserError) {
    var Validator, check;
    check = validate.check;
    return Validator = {
      validate: function(validation, data, controllerName) {
        var field, promises, validatorData;
        promises = [];
        for (field in validation) {
          validatorData = validation[field];
          if ((data[field] != null) || validatorData.required) {
            delete validatorData["default"];
            promises.push(this.validateField(validatorData, field, data[field], controllerName));
          } else if (validatorData["default"]) {
            data[field] = validatorData["default"];
          }
        }
        return Bluebird.map(promises, function(promise) {
          return Bluebird.resolve(promise).reflect();
        }).then(function(results) {
          var error, errors;
          errors = _.filter(results, function(result) {
            return !result.isFulfilled();
          });
          if (errors.length > 0) {
            errors = _.reduce(errors, function(memo, result) {
              var reason;
              reason = result.reason();
              if (reason instanceof Error) {
                throw reason;
              }
              memo[reason.field] = reason.errors;
              return memo;
            }, {});
            error = new UserError('Validate');
            error.errors = errors;
            throw error;
          } else {
            return data;
          }
        });
      },

      /*
      Returns a promise that either resolves, or rejects with a list of errors: i.e.
        field: field
        errors: ['must be less than 8', 'must exist']
      Please note that required needs to be run first
       */
      validateField: function(validators, field, value, controllerName) {
        var promises, validator, validatorData;
        promises = [];
        if (value == null) {
          promises.push(this.runValidate(value, 'required', true, field, controllerName));
        } else if (validators) {
          for (validator in validators) {
            validatorData = validators[validator];
            promises.push(this.runValidate(value, validator, validatorData, field, controllerName));
          }
        }
        return Bluebird.settle(promises).then(function(results) {
          var readableErrors, reason, result;
          readableErrors = (function() {
            var i, len, results1;
            results1 = [];
            for (i = 0, len = results.length; i < len; i++) {
              result = results[i];
              if (!(!result.isFulfilled())) {
                continue;
              }
              reason = result.reason();
              if (reason instanceof Error) {
                throw reason;
              }
              results1.push(reason);
            }
            return results1;
          })();
          if (readableErrors.length > 0) {
            throw {
              errors: readableErrors,
              field: field
            };
          }
        });
      },

      /*
      Returns a promise that either is resolved, or is rejected with the readable error. Note that if validator is "type", then the validatorData
      will be transformed to is<validatorData>.
      Example:
        type: "alphanumeric" => isAlphanumeric
        type: "int" => isInt
       */
      runValidate: function(value, validator, validatorData, field, controllerName) {
        return Bluebird["try"]((function(_this) {
          return function() {
            var args, checker, e, error1, validators, value_part;
            if (validator === "type") {
              if (_.isString(validatorData)) {
                validator = 'is' + validatorData.substr(0, 1).toUpperCase() + validatorData.substr(1);
              } else {
                if (_.isArray(validatorData)) {
                  validators = validatorData[0];
                  if (!_.isArray(value)) {
                    throw new UserError(_this.Messages.isArray);
                  }
                  if (_.isString(validators)) {
                    validators = {
                      type: validators
                    };
                  } else {
                    throw new Error('only types are supported by array validators');
                  }
                  return Bluebird.all((function() {
                    var i, len, results1;
                    results1 = [];
                    for (i = 0, len = value.length; i < len; i++) {
                      value_part = value[i];
                      results1.push(this.validateField(validators, field, value_part, controllerName));
                    }
                    return results1;
                  }).call(_this))["catch"](function() {
                    throw new UserError("should be an array of " + validators.type);
                  });
                } else {
                  throw new Error("Validation method 'is" + validatorData + "' does not exist");
                }
              }
            }
            if (!_this.ValidationMethods[validator]) {
              args = [value];
              if (_this.Messages[validator]) {
                args.push(_this.Messages[validator]);
              }
              if ((checker = check.apply(null, args))[validator]) {
                if (!_.isArray(validatorData)) {
                  validatorData = [validatorData];
                }
                try {
                  checker[validator].apply(checker, validatorData);
                } catch (error1) {
                  e = error1;
                  throw new UserError(e.message);
                }
                return true;
              } else {
                throw new Error("Validation method '" + validator + "' does not exist");
              }
            } else {
              return _this.ValidationMethods[validator](value, validatorData, field, controllerName);
            }
          };
        })(this))["catch"](function(error) {
          return Bluebird.reject(error instanceof UserError ? error.message : error);
        });
      },
      registerValidator: function(name, fn) {
        return this.ValidationMethods[name] = fn;
      },
      Messages: {
        required: "is required",
        isAlphanumeric: "must be alphanumeric",
        isBoolean: "must be a boolean",
        isText: 'must be a string',
        isArray: 'must be an array',
        isDate: 'must be a date'
      },
      ValidationMethods: {
        required: function(value) {
          if (value == null) {
            throw new UserError(Validator.Messages['required']);
          }
        },
        isBoolean: function(value) {
          if (!(value === true || value === false)) {
            throw new UserError(Validator.Messages.isBoolean);
          }
          return true;
        },
        isDate: function(value) {
          if (!(value instanceof Date)) {
            throw new UserError(Validator.Messages.isDate);
          }
          return true;
        },
        isImage: function() {
          return true;
        },
        isFile: function() {
          return true;
        },
        isText: function(value) {
          if (!_.isString(value)) {
            throw new UserError(Validator.Messages.isText);
          }
          return true;
        }
      }
    };
  });

}).call(this);
