// Generated by CoffeeScript 1.6.3
(function() {
  var Q, Validator, check, validate, _;

  _ = require('underscore');

  validate = require('validator');

  check = validate.check;

  Q = require('q');

  module.exports = Validator = {
    validate: function(validation, data, controllerName) {
      var field, promises, validatorData;
      promises = [];
      for (field in validation) {
        validatorData = validation[field];
        if (data[field] || validatorData.required) {
          delete validatorData["default"];
          promises.push(this.validateField(validatorData, field, data[field], controllerName));
        } else if (validatorData["default"]) {
          data[field] = validatorData["default"];
        }
      }
      return Q.allSettled(promises).then(function(results) {
        var deferred, errors;
        deferred = Q.defer();
        errors = _.filter(results, function(result) {
          return result.state !== "fulfilled";
        });
        if (errors.length > 0) {
          errors = _.reduce(errors, function(memo, result) {
            var reason;
            reason = result.reason;
            memo[reason.field] = reason.errors;
            return memo;
          }, {});
          deferred.reject({
            message: "validate",
            error: errors
          });
        } else {
          deferred.resolve(data);
        }
        return deferred.promise;
      });
    },
    /*
    	Returns a promise that either resolves, or rejects with a list of errors: i.e.
    		field: field
    		errors: ['must be less than 8', 'must exist']
    	Please note that required needs to be run first
    */

    validateField: function(validators, field, value, controllerName) {
      var promises, validator, validatorData;
      promises = [];
      if (!value) {
        promises.push(this.runValidate(value, 'required', true, field, controllerName));
      } else if (validators) {
        for (validator in validators) {
          validatorData = validators[validator];
          promises.push(this.runValidate(value, validator, validatorData, field, controllerName));
        }
      }
      return Q.allSettled(promises).then(function(results) {
        var deferred, readableErrors, result;
        deferred = Q.defer();
        readableErrors = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            result = results[_i];
            if (result.state !== "fulfilled") {
              _results.push(result.reason);
            }
          }
          return _results;
        })();
        if (readableErrors.length > 0) {
          deferred.reject({
            errors: readableErrors,
            field: field
          });
        } else {
          deferred.resolve();
        }
        return deferred.promise;
      });
    },
    /*
    	Returns a promise that either is resolved, or is rejected with the readable error. Note that if validator is "type", then the validatorData
    	will be transformed to is<validatorData>.
    	Example:
    		type: "alphanumeric" => isAlphanumeric
    		type: "int" => isInt
    */

    runValidate: function(value, validator, validatorData, field, controllerName) {
      var args, checker, deferred, e;
      deferred = Q.defer();
      try {
        if (validator === "type") {
          validator = 'is' + validatorData.substr(0, 1).toUpperCase() + validatorData.substr(1);
        }
        if (!this.ValidationMethods[validator]) {
          args = [value];
          if (this.Messages[validator]) {
            args.push(this.Messages[validator]);
          }
          if ((checker = check.apply(null, args))[validator]) {
            if (!_.isArray(validatorData)) {
              validatorData = [validatorData];
            }
            checker[validator].apply(checker, validatorData);
            deferred.resolve();
          } else {
            throw new Error("Validation method '" + validator + "' does not exist");
          }
        } else {
          deferred.resolve(this.ValidationMethods[validator](value, validatorData, field, controllerName));
        }
      } catch (_error) {
        e = _error;
        deferred.reject(e.message);
      }
      return deferred.promise;
    },
    registerValidator: function(name, fn) {
      return this.ValidationMethods[name] = fn;
    },
    Messages: {
      required: "is required",
      isAlphanumeric: "must be alphanumeric",
      isBoolean: "must be a boolean",
      isText: 'must be a string'
    },
    ValidationMethods: {
      required: function(value) {
        if (!value) {
          throw new Error(Validator.Messages['required']);
        }
      },
      isBoolean: function(value) {
        return value === true || value === false;
      },
      isFile: function() {
        return true;
      },
      isText: function(value) {
        if (!_.isString(value)) {
          throw new Error(Validator.Messages.isText);
        }
        return true;
      }
    }
  };

}).call(this);
