// Generated by CoffeeScript 1.7.1
(function() {
  (function(generator) {
    var Q, UserError, validate, validator, _;
    if ((typeof exports !== "undefined" && exports !== null) && module.exports) {
      _ = require('underscore');
      validate = require('validator');
      Q = require('q');
      UserError = require('../ez-ctrl/userError');
      return module.exports = generator(_, validate, Q, UserError);
    } else if ((typeof define !== "undefined" && define !== null) && define.amd) {
      return define(['underscore', 'validate', 'q', 'UserError'], generator);
    } else {
      _ = window._, validator = window.validator, Q = window.Q, UserError = window.UserError;
      return window.Validator = generator(_, validator, Q, UserError);
    }
  })(function(_, validate, Q, UserError) {
    var Validator, check;
    check = validate.check;
    return Validator = {
      validate: function(validation, data, controllerName) {
        var field, promises, validatorData;
        promises = [];
        for (field in validation) {
          validatorData = validation[field];
          if ((data[field] != null) || validatorData.required) {
            delete validatorData["default"];
            promises.push(this.validateField(validatorData, field, data[field], controllerName));
          } else if (validatorData["default"]) {
            data[field] = validatorData["default"];
          }
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, error, errors;
          deferred = Q.defer();
          errors = _.filter(results, function(result) {
            return result.state !== "fulfilled";
          });
          if (errors.length > 0) {
            errors = _.reduce(errors, function(memo, result) {
              var reason;
              reason = result.reason;
              if (reason instanceof Error) {
                throw reason;
              }
              memo[reason.field] = reason.errors;
              return memo;
            }, {});
            error = new UserError('Validate');
            error.errors = errors;
            deferred.reject(error);
          } else {
            deferred.resolve(data);
          }
          return deferred.promise;
        });
      },

      /*
      Returns a promise that either resolves, or rejects with a list of errors: i.e.
        field: field
        errors: ['must be less than 8', 'must exist']
      Please note that required needs to be run first
       */
      validateField: function(validators, field, value, controllerName) {
        var promises, validator, validatorData;
        promises = [];
        if (value == null) {
          promises.push(this.runValidate(value, 'required', true, field, controllerName));
        } else if (validators) {
          for (validator in validators) {
            validatorData = validators[validator];
            promises.push(this.runValidate(value, validator, validatorData, field, controllerName));
          }
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, readableErrors, result;
          deferred = Q.defer();
          readableErrors = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              result = results[_i];
              if (!(result.state !== "fulfilled")) {
                continue;
              }
              if (result.reason instanceof Error) {
                throw result.reason;
              }
              _results.push(result.reason);
            }
            return _results;
          })();
          if (readableErrors.length > 0) {
            deferred.reject({
              errors: readableErrors,
              field: field
            });
          } else {
            deferred.resolve();
          }
          return deferred.promise;
        });
      },

      /*
      Returns a promise that either is resolved, or is rejected with the readable error. Note that if validator is "type", then the validatorData
      will be transformed to is<validatorData>.
      Example:
        type: "alphanumeric" => isAlphanumeric
        type: "int" => isInt
       */
      runValidate: function(value, validator, validatorData, field, controllerName) {
        return Q.fcall((function(_this) {
          return function() {
            var args, checker, e, validators, value_part;
            if (validator === "type") {
              if (_.isString(validatorData)) {
                validator = 'is' + validatorData.substr(0, 1).toUpperCase() + validatorData.substr(1);
              } else {
                if (_.isArray(validatorData)) {
                  validators = validatorData[0];
                  if (!_.isArray(value)) {
                    throw new UserError(_this.Messages.isArray);
                  }
                  if (_.isString(validators)) {
                    validators = {
                      type: validators
                    };
                  } else {
                    throw new Error('only types are supported by array validators');
                  }
                  return Q.all((function() {
                    var _i, _len, _results;
                    _results = [];
                    for (_i = 0, _len = value.length; _i < _len; _i++) {
                      value_part = value[_i];
                      _results.push(this.validateField(validators, field, value_part, controllerName));
                    }
                    return _results;
                  }).call(_this)).fail(function() {
                    throw new UserError("should be an array of " + validators.type);
                  });
                } else {
                  throw new Error("Validation method 'is" + validatorData + "' does not exist");
                }
              }
            }
            if (!_this.ValidationMethods[validator]) {
              args = [value];
              if (_this.Messages[validator]) {
                args.push(_this.Messages[validator]);
              }
              if ((checker = check.apply(null, args))[validator]) {
                if (!_.isArray(validatorData)) {
                  validatorData = [validatorData];
                }
                try {
                  checker[validator].apply(checker, validatorData);
                } catch (_error) {
                  e = _error;
                  throw new UserError(e.message);
                }
                return true;
              } else {
                throw new Error("Validation method '" + validator + "' does not exist");
              }
            } else {
              return _this.ValidationMethods[validator](value, validatorData, field, controllerName);
            }
          };
        })(this)).fail(function(error) {
          return Q.reject(error instanceof UserError ? error.message : error);
        });
      },
      registerValidator: function(name, fn) {
        return this.ValidationMethods[name] = fn;
      },
      Messages: {
        required: "is required",
        isAlphanumeric: "must be alphanumeric",
        isBoolean: "must be a boolean",
        isText: 'must be a string',
        isArray: 'must be an array',
        isDate: 'must be a date'
      },
      ValidationMethods: {
        required: function(value) {
          if (value == null) {
            throw new UserError(Validator.Messages['required']);
          }
        },
        isBoolean: function(value) {
          if (!(value === true || value === false)) {
            throw new UserError(Validator.Messages.isBoolean);
          }
          return true;
        },
        isDate: function(value) {
          if (!(value instanceof Date)) {
            throw new UserError(Validator.Messages.isDate);
          }
          return true;
        },
        isFile: function() {
          return true;
        },
        isText: function(value) {
          if (!_.isString(value)) {
            throw new UserError(Validator.Messages.isText);
          }
          return true;
        }
      }
    };
  });

}).call(this);
