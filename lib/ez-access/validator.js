// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Q, exportObject, loadValidator, underscore, validate, validator;
  loadValidator = function(Q, _, EventEmitter, validate) {
    var Validator, check;
    check = validate.check;
    Validator = {
      validate: function(validation, data, controllerName) {
        var field, promises, validatorData;
        promises = [];
        for (field in validation) {
          validatorData = validation[field];
          promises.push(this.validateField(validatorData, field, data[field], controllerName));
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, errors;
          deferred = Q.defer();
          errors = _.filter(results, function(result) {
            return result.state !== "fulfilled";
          });
          if (errors.length > 0) {
            errors = _.reduce(errors, function(memo, result) {
              var reason;
              reason = result.reason;
              if (!memo[reason.field]) {
                memo[reason.field] = [];
              }
              memo[reason.field] = memo[reason.field].concat(reason.errors);
              return memo;
            }, {});
            deferred.reject({
              message: "validate",
              error: errors
            });
          } else {
            deferred.resolve(data);
          }
          return deferred.promise;
        });
      },
      /*
      			Returns a promise that either resolves, or rejects with a list of errors: i.e.
      				field: field
      				errors: ['must be less than 8', 'must exist']
      */

      validateField: function(validators, field, value, controllerName) {
        var promises, validator, validatorData;
        promises = [];
        if (!value) {
          if (validators.required) {
            promises.push(this.runValidate(value, 'required', true, field, controllerName));
          } else {
            return true;
          }
        } else if (validators) {
          for (validator in validators) {
            validatorData = validators[validator];
            promises.push(this.runValidate(value, validator, validatorData, field, controllerName));
          }
        }
        return Q.allSettled(promises).then(function(results) {
          var deferred, error, readableErrors, result, _i, _len;
          deferred = Q.defer();
          readableErrors = [];
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            result = results[_i];
            if (result.state !== "fulfilled") {
              error = result.reason;
              readableErrors.push(error);
            }
          }
          if (readableErrors.length > 0) {
            deferred.reject({
              errors: readableErrors,
              field: field
            });
          } else {
            deferred.resolve();
          }
          return deferred.promise;
        });
      },
      /*
      			Returns a promise that either is resolved, or is rejected with the readable error. Note that if validator is "type", then the validatorData
      			will be transformed to is<validatorData>.
      			Example:
      				type: "alphanumeric" => isAlphanumeric
      				type: "int" => isInt
      */

      runValidate: function(value, validator, validatorData, field, controllerName) {
        var args, checker, deferred, e;
        deferred = Q.defer();
        try {
          if (validator === "type") {
            validator = 'is' + validatorData.substr(0, 1).toUpperCase() + validatorData.substr(1);
          }
          if (!this.ValidationMethods[validator]) {
            args = [value];
            if (this.ValidationMessages[validator]) {
              args.push(this.ValidationMessages[validator]);
            }
            if ((checker = check.apply(null, args))[validator]) {
              if (!_.isArray(validatorData)) {
                validatorData = [validatorData];
              }
              checker[validator].apply(checker, validatorData);
              deferred.resolve();
            } else {
              if (typeof Validator.emit === "function") {
                Validator.emit("error", {
                  error: "MissingMethod",
                  validator: validator,
                  validatorData: validatorData
                });
              }
              throw new Error("Validation method '" + validator + "' does not exist");
            }
          } else {
            deferred.resolve(this.ValidationMethods[validator](value, validatorData, field, controllerName));
          }
        } catch (_error) {
          e = _error;
          deferred.reject(e.message);
        }
        return deferred.promise;
      },
      registerValidator: function(name, fn) {
        return this.ValidationMethods[name] = fn;
      },
      ValidationMessages: {
        required: "is required",
        isAlphanumeric: "must be alphanumeric"
      },
      ValidationMethods: {
        required: function(value) {
          if (!value) {
            throw new Error(Validator.ValidationMessages['required']);
          }
        }
      }
    };
    if (EventEmitter) {
      EventEmitter.call(Validator);
      Validator.__proto__ = EventEmitter.prototype;
    }
    return Validator;
  };
  if (!(typeof process === 'undefined' || !process.versions)) {
    EventEmitter = require('events').EventEmitter;
    underscore = require('underscore');
    validator = require('validator');
    Q = require('q');
    exportObject = function(object) {
      return module.exports = object;
    };
  } else {
    underscore = window._;
    EventEmitter = null;
    if (!window.Q) {
      throw new Error("Q.js is required for ez-validator!");
    }
    if (!window.validate) {
      throw new Error("validator.js is required for ez-validator!");
    }
    Q = window.Q;
    validate = window.validate;
    exportObject = function(object) {
      return window.Validator = object;
    };
  }
  return exportObject(loadValidator(Q, underscore, EventEmitter, validate));
})();
